# 데이터베이스 잠금 메커니즘

## 목차
- [소개](#소개)
- [공유 잠금(Shared Lock)](#공유-잠금shared-lock)
- [배타적 잠금(Exclusive Lock)](#배타적-잠금exclusive-lock)
- [잠금 호환성 매트릭스](#잠금-호환성-매트릭스)
- [잠금 확장](#잠금-확장)
- [교착 상태](#교착-상태)
- [잠금 세분성](#잠금-세분성)
- [격리 수준과 잠금](#격리-수준과-잠금)
- [다양한 DBMS에서의 잠금 구현](#다양한-dbms에서의-잠금-구현)

## 소개

데이터베이스 잠금(lock)은 다중 사용자 환경에서 동시성 제어를 구현하는 기본 메커니즘입니다. 잠금은 트랜잭션이 데이터베이스 객체(테이블, 행, 페이지 등)에 접근할 때 다른 트랜잭션의 접근을 제한함으로써 데이터 무결성을 보장합니다. 

가장 기본적인 두 가지 유형의 잠금은 공유 잠금(Shared Lock)과 배타적 잠금(Exclusive Lock)입니다.

## 공유 잠금(Shared Lock)

### 개념
공유 잠금(S-Lock)은 데이터를 읽기만 할 때 사용되는 잠금 메커니즘입니다.

### 특징
- **읽기 작업(SELECT)**: 주로 데이터를 읽는 작업에서 사용됩니다.
- **동시 읽기 허용**: 여러 트랜잭션이 동시에 같은 데이터에 대해 공유 잠금을 획득할 수 있습니다.
- **수정 방지**: 공유 잠금이 설정된 데이터는 배타적 잠금을 필요로 하는 작업(쓰기)에 의해 수정될 수 없습니다.

### 사용 예시
```sql
-- 명시적 공유 잠금 설정 (MySQL)
SELECT * FROM 사용자 WHERE 사용자ID = 1 LOCK IN SHARE MODE;

-- SQL Server에서의 사용
SELECT * FROM 사용자 WITH (HOLDLOCK) WHERE 사용자ID = 1;
```

## 배타적 잠금(Exclusive Lock)

### 개념
배타적 잠금(X-Lock)은 데이터를 수정할 때 사용되는 잠금 메커니즘입니다.

### 특징
- **쓰기 작업(INSERT, UPDATE, DELETE)**: 데이터를 변경하는 작업에서 사용됩니다.
- **독점 접근**: 한 트랜잭션만이 특정 데이터에 대한 배타적 잠금을 가질 수 있습니다.
- **다른 잠금 차단**: 배타적 잠금이 설정되면 다른 트랜잭션은 해당 데이터에 대한 어떠한 잠금(공유 또는 배타적)도 획득할 수 없습니다.

### 사용 예시
```sql
-- 명시적 배타적 잠금 설정 (SQL Server)
SELECT * FROM 사용자 WITH (XLOCK) WHERE 사용자ID = 1;

-- 데이터 수정 시 자동 배타적 잠금 획득
UPDATE 사용자 SET 이름 = '홍길동' WHERE 사용자ID = 1;
```

## 잠금 호환성 매트릭스

공유 잠금과 배타적 잠금 간의 호환성은 다음과 같습니다:

| 기존 잠금 / 요청 잠금 | 공유 잠금(S) | 배타적 잠금(X) |
|----------------------|------------|-------------|
| 공유 잠금(S)           | 가능        | 불가능       |
| 배타적 잠금(X)         | 불가능      | 불가능       |

- 공유 잠금 + 공유 잠금: 여러 트랜잭션이 동시에 같은 데이터를 읽을 수 있음
- 공유 잠금 + 배타적 잠금: 한 트랜잭션이 읽고 있는 데이터를 다른 트랜잭션이 수정할 수 없음
- 배타적 잠금 + 공유 잠금: 한 트랜잭션이 수정 중인 데이터를 다른 트랜잭션이 읽을 수 없음
- 배타적 잠금 + 배타적 잠금: 한 트랜잭션이 수정 중인 데이터를 다른 트랜잭션이 수정할 수 없음

## 잠금 확장

잠금 확장(Lock Escalation)은 세밀한 수준의 많은 잠금(행 수준)을 더 큰 단위의 잠금(테이블 수준)으로 변환하는 프로세스입니다.

### 목적
- 잠금 관리 오버헤드 감소
- 시스템 리소스 절약

### 작동 방식
- 트랜잭션이 특정 테이블의 많은 행에 잠금을 획득하면, DBMS는 개별 행 잠금을 테이블 전체 잠금으로 변환할 수 있습니다.
- 이 임계값은 DBMS마다 다르며 구성 가능한 경우가 많습니다.

## 교착 상태

교착 상태(Deadlock)는 두 개 이상의 트랜잭션이 서로가 보유한 잠금을 기다리며 무한정 대기하는 상황입니다.

### 예시
- 트랜잭션 A: 자원 1에 대한 잠금을 보유하고 자원 2에 대한 잠금을 기다림
- 트랜잭션 B: 자원 2에 대한 잠금을 보유하고 자원 1에 대한 잠금을 기다림

### 해결 방법
- **교착 상태 감지**: DBMS는 주기적으로 교착 상태를 감지합니다.
- **교착 상태 해결**: 일반적으로 하나의 트랜잭션을 희생(롤백)하여 다른 트랜잭션이 진행할 수 있게 합니다.
- **타임아웃**: 일정 시간 동안 잠금을 획득하지 못하면 트랜잭션을 중단합니다.

## 잠금 세분성

잠금은 다양한 세분성 수준에서 적용될 수 있습니다:

1. **데이터베이스 수준 잠금**: 전체 데이터베이스를 잠금
2. **테이블 수준 잠금**: 특정 테이블 전체를 잠금
3. **페이지 수준 잠금**: 데이터베이스 페이지(여러 행을 포함하는 저장 단위)를 잠금
4. **행 수준 잠금**: 테이블의 특정 행만 잠금
5. **칼럼 수준 잠금**: 특정 행의 특정 칼럼만 잠금 (일부 DBMS에서만 지원)

세분성이 낮을수록(예: 데이터베이스 수준) 관리는 쉽지만 동시성이 감소합니다. 세분성이 높을수록(예: 행 수준) 동시성은 향상되지만 관리 오버헤드가 증가합니다.

## 격리 수준과 잠금

트랜잭션 격리 수준은 잠금 전략에 영향을 미칩니다:

1. **READ UNCOMMITTED**: 일반적으로 잠금을 최소화하거나 사용하지 않음
2. **READ COMMITTED**: 쿼리 실행 중에만 공유 잠금 유지
3. **REPEATABLE READ**: 트랜잭션 종료까지 읽은 모든 데이터에 공유 잠금 유지
4. **SERIALIZABLE**: 가장 엄격한 잠금 사용, 트랜잭션이 접근하는 범위에 대한 잠금 설정

## 다양한 DBMS에서의 잠금 구현

각 DBMS는 잠금 메커니즘을 다르게 구현합니다:

### MySQL (InnoDB)
- 행 수준 잠금 지원
- 명시적 잠금: `SELECT ... FOR SHARE` (공유 잠금), `SELECT ... FOR UPDATE` (배타적 잠금)
- 다양한 격리 수준 지원

### PostgreSQL
- 다중 버전 동시성 제어(MVCC) 사용으로 읽기 작업이 쓰기 작업을 차단하지 않음
- 명시적 잠금: `SELECT ... FOR SHARE`, `SELECT ... FOR UPDATE`

### Oracle
- 행 수준 잠금 및 MVCC 결합
- `SELECT ... FOR UPDATE` 구문 지원
- 낙관적 및 비관적 잠금 모두 지원

### SQL Server
- 행, 페이지, 테이블 수준 잠금 지원
- 힌트를 통한 잠금 제어: `WITH (HOLDLOCK)`, `WITH (XLOCK)`
- 교착 상태 감지 및 해결 메커니즘 내장