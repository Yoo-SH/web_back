# B-Tree와 B+Tree 구조 분석

## 목차
- [개요](#개요)
- [B-Tree 구조](#b-tree-구조)
- [B-Tree의 한계점](#b-tree의-한계점)
- [B+Tree 구조](#b+tree-구조)
- [B+Tree의 장점](#b+tree의-장점)
- [성능 비교](#성능-비교)
- [활용 사례](#활용-사례)

## 개요
데이터베이스 시스템에서 인덱싱을 위해 사용되는 B-Tree와 B+Tree는 대용량 데이터를 효율적으로 관리하기 위한 자료구조입니다.

## B-Tree 구조
- 모든 리프 노드는 같은 레벨에 있음
- 각 노드는 최소 m/2-1개에서 최대 m-1개의 키를 가질 수 있음
- 각 노드의 키는 오름차순으로 정렬되어 있음
- 데이터가 노드 내에 직접 저장됨

![Image](https://github.com/user-attachments/assets/fba6172a-a128-47f6-9d78-21eeb109f51b)

![Image](https://github.com/user-attachments/assets/4b9cfb0f-9059-4e76-a73c-e2e594b232f8)

## B-Tree의 한계점
1. **공간 활용의 비효율성**
    - 모든 노드에 데이터를 저장하여 메모리 사용량이 큼
    - 중복된 키 값들이 여러 노드에 존재할 수 있음

2. **순차 접근의 어려움**
    - 리프 노드들 간의 연결이 없어 순차 검색 시 비효율적
    - 범위 검색 시 루트부터 다시 탐색해야 함

3. **캐시 효율성 저하**
    - 데이터가 각 노드에 분산되어 있어 캐시 효율이 떨어짐

![Image](https://github.com/user-attachments/assets/445d148e-fa2b-40b2-a54b-72f215a2a8c9)

## B+Tree 구조
- 리프 노드만이 실제 데이터를 가짐
- 내부 노드는 인덱스 역할만 수행
- 리프 노드들은 링크드 리스트로 연결됨
- 모든 키가 리프 노드에 나타남

![Image](https://github.com/user-attachments/assets/cc85353b-9539-48c3-9435-31e1190552cc)

## B+Tree의 장점
1. **향상된 공간 활용**
    - 데이터는 리프 노드에만 저장되어 메모리 효율적
    - 내부 노드는 인덱스 정보만 보유

2. **효율적인 범위 검색**
    - 리프 노드간 연결로 순차 접근 용이
    - 범위 검색 시 한 번의 탐색으로 순차 접근 가능

3. **향상된 캐시 성능**
    - 데이터가 리프 노드에 집중되어 캐시 효율성 증가
    - 내부 노드의 캐시 적중률 향상

![Image](https://github.com/user-attachments/assets/2f891291-6ae3-4404-bcf1-6a3244c9245d)
## 성능 비교

| 작업 유형 | B-Tree | B+Tree |
|---------|---------|---------|
| 검색 | O(log n) | O(log n) |
| 삽입 | O(log n) | O(log n) |
| 삭제 | O(log n) | O(log n) |
| 순차 접근 | O(n) | O(n) |
| 범위 검색 | 비효율적 | 효율적 |

## 활용 사례
- B-Tree
    - 일반적인 데이터베이스 인덱싱
    - 파일 시스템 구현

- B+Tree
    - RDBMS의 인덱스 구현 (MySQL, PostgreSQL 등)
    - 파일 시스템의 디렉토리 구조