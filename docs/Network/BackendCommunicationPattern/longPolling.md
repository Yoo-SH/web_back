# 롱 폴링 백엔드 통신 패턴

## 목차
- [개요](#개요)
- [롱 폴링 작동 방식](#롱-폴링-작동-방식)
- [구현 가이드](#구현-가이드)
- [장점](#장점)
- [단점](#단점)
- [롱 폴링 사용 시기](#롱-폴링-사용-시기)
- [대안 기술](#대안-기술)
- [코드 예제](#코드-예제)
- [모범 사례](#모범-사례)
- [일반적인 문제점](#일반적인-문제점)
- [참고 자료](#참고-자료)

## 개요

롱 폴링은 전통적인 폴링 방식보다 낮은 지연시간으로 서버-클라이언트 통신을 가능하게 하는 HTTP 통신 기술입니다. 이는 전통적인 폴링의 변형으로, 서버가 정보를 사용할 수 있게 되는 즉시 클라이언트에게 푸시할 수 있어 클라이언트의 빈번한 요청 필요성을 줄여줍니다.

롱 폴링은 일반 폴링과 WebSocket과 같은 더 고급 실시간 기술 사이의 격차를 메워주며, 거의 실시간 업데이트가 필요한 많은 웹 애플리케이션에 유용한 패턴입니다.

<Image src = "https://github.com/user-attachments/assets/498080ac-b618-4684-a677-24ce1afdac74" width="500"/>

## 롱 폴링 작동 방식

1. **클라이언트가 요청 시작**: 클라이언트가 서버에 HTTP 요청을 보냅니다.
2. **서버가 요청을 유지**: 서버는 즉시 응답하는 대신 다음 중 하나가 발생할 때까지 연결을 열어둡니다:
   - 새 데이터가 사용 가능해짐
   - 타임아웃 발생
   - 연결이 종료됨
3. **서버 응답**: 이러한 이벤트 중 하나가 발생하면 서버는 응답을 보냅니다.
4. **클라이언트가 새 요청 시작**: 응답을 받은 직후, 클라이언트는 사이클을 유지하기 위해 새 요청을 시작합니다.

이는 서버가 표준 HTTP 프로토콜을 사용하면서도 최소한의 지연으로 클라이언트에게 데이터를 푸시할 수 있게 해주는 지속적인 열린 연결 사이클을 만듭니다.

## 구현 가이드

### 서버 측 구현

서버는 다음과 같이 설계되어야 합니다:
1. HTTP 연결을 수락하고 유지
2. 어떤 클라이언트가 어떤 데이터를 기다리고 있는지 추적
3. 적절한 데이터가 사용 가능해지면 클라이언트에게 응답
4. 적절한 타임아웃 처리 구현

### 클라이언트 측 구현

클라이언트는 다음과 같이 설계되어야 합니다:
1. 장시간 열려 있을 수 있는 HTTP 요청 생성
2. 타임아웃과 연결 오류를 우아하게 처리
3. 서버 응답을 처리하고 즉시 새 연결 시작
4. 재연결 전략 관리

## 장점

- **넓은 호환성**: 표준 HTTP 인프라와 함께 작동
- **낮은 지연시간**: 일반 폴링에 비해 더 낮은 지연시간
- **방화벽 친화적**: 표준 HTTP 포트(80/443) 사용
- **간단한 구현**: WebSocket보다 구현이 쉬움
- **무상태**: 무상태 서버 아키텍처와 함께 작동 가능
- **확장성**: 로드 밸런서와 다중 서버에서 작동 가능

## 단점

- **리소스 집약적**: 서버에서 열린 연결을 유지
- **타임아웃 처리**: 타임아웃의 주의 깊은 관리 필요
- **연결 오버헤드**: 각 롱 폴은 새로운 HTTP 연결 생성
- **잠재적 지연**: 네트워크 중개자가 응답을 버퍼링할 수 있음
- **제한된 확장성**: 대규모 애플리케이션의 경우 WebSocket보다 덜 효율적
- **프로토콜 오버헤드**: HTTP 헤더가 각 요청에 대한 대역폭 오버헤드 추가

## 롱 폴링 사용 시기

롱 폴링은 다음과 같은 경우에 이상적입니다:
- 실시간 업데이트는 아니지만 거의 실시간에 가까운 업데이트가 필요한 애플리케이션
- WebSocket이 지원되지 않거나 차단된 환경
- 전체 WebSocket 연결이 비효율적인 간헐적 업데이트가 있는 시스템
- 레거시 시스템 통합
- 더 간단한 구현 요구사항
- 브라우저 호환성 우려가 있는 경우

## 대안 기술

### 전통적인 폴링
- 클라이언트가 주기적으로 업데이트 요청
- 더 높은 지연시간
- 더 빈번한 요청
- 덜 복잡한 서버 측 구현

### WebSocket
- 전이중 통신 채널
- 롱 폴링보다 낮은 지연시간
- 고빈도 업데이트에 더 적합
- 더 복잡한 구현
- 잠재적인 방화벽/프록시 이슈

### 서버 전송 이벤트 (SSE)
- 일방향 서버-클라이언트 채널
- 간단한 API
- 네이티브 브라우저 지원
- 일방향 데이터 스트림의 경우 롱 폴링보다 나음
- IE/Edge에서 제한된 지원

### HTTP/2 서버 푸시
- 서버가 클라이언트에게 리소스 푸시
- HTTP/2와 통합
- 효율적인 리소스 전달
- 애플리케이션 데이터 메시징용으로 설계되지 않음

## 코드 예제

### Node.js 서버 예제 (Express)

```javascript
const express = require('express');
const app = express();
const PORT = 3000;

// 활성 연결을 저장할 저장소
const connections = [];
let messageId = 0;

app.get('/poll', (req, res) => {
  // 적절한 헤더 설정
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // 연결 저장
  connections.push({
    id: ++messageId,
    res
  });
  
  // 연결이 무기한 유지되지 않도록 타임아웃 설정
  req.on('close', () => {
    // 연결이 닫히면 제거
    const index = connections.findIndex(conn => conn.id === messageId);
    if (index !== -1) {
      connections.splice(index, 1);
    }
  });
  
  // 타임아웃 설정 (30초)
  setTimeout(() => {
    // 연결이 여전히 존재하면 타임아웃 응답 전송
    const index = connections.findIndex(conn => conn.id === messageId);
    if (index !== -1) {
      connections[index].res.json({ timeout: true, message: "새 데이터 없음" });
      connections.splice(index, 1);
    }
  }, 30000);
});

// 모든 연결된 클라이언트에게 메시지를 보내는 엔드포인트
app.get('/send-message', (req, res) => {
  const message = req.query.message || "기본 메시지";
  
  // 모든 연결된 클라이언트에게 메시지 전송
  connections.forEach(conn => {
    conn.res.json({ message });
  });
  
  // 연결 목록 초기화
  connections.length = 0;
  
  res.send('모든 연결된 클라이언트에게 메시지 전송됨');
});

app.listen(PORT, () => {
  console.log(`서버가 포트 ${PORT}에서 실행 중`);
});
```

### JavaScript 클라이언트 예제

```javascript
function longPoll() {
  fetch('/poll')
    .then(response => response.json())
    .then(data => {
      // 수신된 데이터 처리
      console.log('데이터 수신:', data);
      
      // 여기서 데이터 처리
      if (data.message) {
        displayMessage(data.message);
      }
      
      // 즉시 새 롱 폴링 요청 시작
      longPoll();
    })
    .catch(error => {
      console.error('롱 폴링 오류:', error);
      
      // 오류 발생 시 잠시 기다린 후 재연결
      setTimeout(longPoll, 5000);
    });
}

// 초기 롱 폴링 시작
longPoll();

function displayMessage(message) {
  const messagesDiv = document.getElementById('messages');
  messagesDiv.innerHTML += `<p>${message}</p>`;
}
```

## 모범 사례

1. **적절한 타임아웃 구현**
   - 서버 측: 연결이 유지되는 시간 제한
   - 클라이언트 측: 연결 타임아웃을 우아하게 처리

2. **연결 풀링 사용**
   - 오버헤드를 줄이기 위해 가능한 경우 연결 재사용

3. **지수 백오프 구현**
   - 연결 문제 발생 시 점진적으로 재시도 간격 증가

4. **재연결 시도에 지터 추가**
   - 무작위화된 재연결 시간으로 "thundering herd" 문제 방지

5. **연결 해제를 우아하게 처리**
   - 클라이언트와 서버 모두 예상치 못한 연결 해제 처리

6. **리소스 제한 고려**
   - 최대 동시 연결 수 인식
   - 서버 리소스 모니터링

7. **데이터 배치 처리 구현**
   - 폴링 간격 동안 여러 이벤트가 발생할 때 업데이트 일괄 처리

8. **가능한 경우 HTTP/2 사용**
   - 연결 오버헤드 감소

9. **적절한 오류 처리 추가**
   - 클라이언트와 서버 모두 네트워크 오류 처리

10. **보안 영향 고려**
    - 폴링 엔드포인트에 인증 구현
    - 요청 매개변수 검증

## 일반적인 문제점

1. **프록시 서버 타임아웃**
   - 많은 프록시가 30-60초 후 유휴 연결을 닫음
   - 해결책: 더 짧은 타임아웃과 재연결 로직 사용

2. **로드 밸런서 문제**
   - 로드 밸런서가 장시간 연결을 방해할 수 있음
   - 해결책: 로드 밸런서를 적절히 구성하거나 고정 세션 사용

3. **연결 제한**
   - 브라우저가 동일 도메인에 대한 동시 연결 수 제한
   - 해결책: 다른 연결 최소화 또는 도메인 샤딩 사용

4. **서버 리소스 관리**
   - 각 연결이 서버 리소스 소비
   - 해결책: 적절한 연결 관리 및 타임아웃 구현

5. **클라이언트 측 메모리 누수**
   - 콜백 및 이벤트 리스너의 부적절한 처리
   - 해결책: 연결이 닫힐 때 적절한 정리

6. **순서 보장**
   - 메시지가 순서대로 도착하지 않을 수 있음
   - 해결책: 시퀀스 번호 또는 타임스탬프 포함

